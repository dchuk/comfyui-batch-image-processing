---
phase: 03-batch-iteration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/iteration_state.py
  - utils/queue_control.py
  - tests/test_iteration_state.py
  - tests/test_queue_control.py
autonomous: true

must_haves:
  truths:
    - "Iteration state persists across node executions within same session"
    - "State resets when directory path changes"
    - "Queue trigger function works when PromptServer available"
    - "Queue trigger gracefully handles missing PromptServer (testing context)"
    - "Auto Queue stops when batch completes"
  artifacts:
    - path: "utils/iteration_state.py"
      provides: "IterationState class with class-level state management"
      exports: ["IterationState"]
    - path: "utils/queue_control.py"
      provides: "Queue triggering utilities including stop signal"
      exports: ["trigger_next_queue", "stop_auto_queue", "HAS_SERVER"]
    - path: "tests/test_iteration_state.py"
      provides: "Unit tests for iteration state"
      min_lines: 50
    - path: "tests/test_queue_control.py"
      provides: "Unit tests for queue control including stop signal"
      min_lines: 40
  key_links:
    - from: "utils/iteration_state.py"
      to: "os.path.normpath"
      via: "path normalization"
      pattern: "os\\.path\\.normpath"
    - from: "utils/queue_control.py"
      to: "server.PromptServer"
      via: "conditional import"
      pattern: "from server import PromptServer"
    - from: "utils/queue_control.py"
      to: "PromptServer.instance.send_sync"
      via: "stop signal on batch complete"
      pattern: "send_sync.*interrupt"
---

<objective>
Create the iteration state management and queue control utilities that will power batch iteration.

Purpose: These utilities provide the foundation for tracking position across workflow executions and triggering the next queue item when batch continues, plus stopping Auto Queue when batch completes.

Output: Two utility modules with comprehensive tests - `iteration_state.py` for state tracking and `queue_control.py` for queue triggering and stopping.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-batch-iteration/03-CONTEXT.md
@.planning/phases/03-batch-iteration/03-RESEARCH.md
@utils/file_utils.py
@utils/image_utils.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create iteration state management utility</name>
  <files>utils/iteration_state.py, tests/test_iteration_state.py</files>
  <action>
Create `utils/iteration_state.py` with an `IterationState` class that manages batch iteration state.

Requirements from CONTEXT.md decisions:
- Class-level state dictionary keyed by normalized directory path (use os.path.normpath + os.path.abspath)
- Track: index (0-based), total_count, last_directory, status ('idle', 'processing', 'completed')
- Methods:
  - `get_state(directory: str) -> dict`: Get or initialize state for a directory
  - `reset(directory: str)`: Reset index to 0 and status to 'idle' for a directory
  - `advance(directory: str) -> int`: Increment index and return new value
  - `is_complete(directory: str) -> bool`: Check if index >= total_count
  - `set_total_count(directory: str, count: int)`: Set total image count
  - `check_directory_change(directory: str, previous_directory: str) -> bool`: Return True if directory changed (after normalization)
  - `wrap_index(directory: str)`: Reset index to 0 when batch completes (for re-run without manual reset)

Implementation notes:
- Use `cls._instances: dict = {}` as class variable for state storage
- Normalize paths with `os.path.normpath(os.path.abspath(directory))` to handle path variations
- Follow the pattern from 03-RESEARCH.md code examples

Create `tests/test_iteration_state.py` with tests for:
- State initialization for new directory
- State persistence across multiple get_state calls
- Index advancement
- Completion detection
- Directory change detection with path variations (trailing slash, relative vs absolute)
- Reset functionality
- Index wrapping after completion


Use the same test patterns from existing tests (see conftest.py for fixtures).
  </action>
  <verify>Run `python -m pytest tests/test_iteration_state.py -v` - all tests pass</verify>
  <done>IterationState class manages batch state with path normalization, and all tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create queue control utility with stop signal</name>
  <files>utils/queue_control.py, tests/test_queue_control.py</files>
  <action>
Create `utils/queue_control.py` with queue triggering and stopping utilities.

Requirements:
- Conditional import of `PromptServer` from `server` module (ComfyUI built-in)
- Export `HAS_SERVER` boolean indicating if PromptServer is available
- Function `trigger_next_queue() -> bool`: Trigger ComfyUI to queue another execution
  - If HAS_SERVER and PromptServer.instance exists, call `PromptServer.instance.send_sync("impact-add-queue", {})`
  - Return True if triggered, False if not available
- Function `stop_auto_queue() -> bool`: Signal ComfyUI to stop Auto Queue when batch completes
  - If HAS_SERVER and PromptServer.instance exists, call `PromptServer.instance.send_sync("impact-stop-auto-queue", {})`
  - Note: Research the exact ComfyUI API method. Try "interrupt" or "BKPrompt/cancel" if impact method unavailable.
  - Fallback approach: Send empty prompt or set a flag that batch_loader reads to not trigger next
  - Return True if signal sent, False if not available
- Function `should_continue(current_index: int, total_count: int) -> bool`: Return True if `current_index < total_count - 1`

Implementation pattern from 03-RESEARCH.md:
```python
try:
    from server import PromptServer
    HAS_SERVER = True
except ImportError:
    PromptServer = None
    HAS_SERVER = False
```

Guard against None with: `if HAS_SERVER and PromptServer is not None and PromptServer.instance is not None`

For stop_auto_queue, research ComfyUI API. Possible approaches:
1. `PromptServer.instance.send_sync("impact-stop-auto-queue", {})` - if using Impact Pack integration
2. `PromptServer.instance.send_sync("comfyui.interrupt", {})` - native interrupt
3. Check if there's an API endpoint at `/interrupt` and call via internal request

Create `tests/test_queue_control.py` with tests for:
- `should_continue` returns True when index < total - 1
- `should_continue` returns False when index >= total - 1
- `trigger_next_queue` returns False when HAS_SERVER is False (default in test env)
- `stop_auto_queue` returns False when HAS_SERVER is False (default in test env)
- Mock test for trigger_next_queue calling send_sync when server available
- Mock test for stop_auto_queue calling send_sync when server available

Use unittest.mock to mock PromptServer for testing the trigger and stop paths.
  </action>
  <verify>Run `python -m pytest tests/test_queue_control.py -v` - all tests pass</verify>
  <done>Queue control utilities work correctly including stop_auto_queue, with graceful degradation when PromptServer unavailable</done>
</task>

<task type="auto">
  <name>Task 3: Update utils package exports</name>
  <files>utils/__init__.py</files>
  <action>
Update `utils/__init__.py` to export the new modules:
- Import and export `IterationState` from `iteration_state`
- Import and export `trigger_next_queue`, `stop_auto_queue`, `should_continue`, `HAS_SERVER` from `queue_control`

Follow the existing pattern in utils/__init__.py for how exports are structured.
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.utils import IterationState, trigger_next_queue, stop_auto_queue, should_continue, HAS_SERVER; print('OK')"` from project root</verify>
  <done>New utilities including stop_auto_queue are importable from the utils package</done>
</task>

</tasks>

<verification>
Run full test suite: `python -m pytest tests/ -v`
All tests pass including new iteration state and queue control tests.
</verification>

<success_criteria>
- IterationState class persists state across calls with proper path normalization
- Queue trigger gracefully handles missing PromptServer
- stop_auto_queue function implemented and exported
- should_continue correctly determines when batch should continue
- All new tests pass
- Utilities are exported from utils package
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-iteration/03-01-SUMMARY.md`
</output>
