---
phase: 03-batch-iteration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - nodes/batch_loader.py
  - tests/test_batch_loader.py
autonomous: true

must_haves:
  truths:
    - "Each image triggers a separate workflow execution via queue-per-image pattern"
    - "Node outputs current image index (0-based)"
    - "Node outputs total image count"
    - "Processing proceeds through all images in order"
    - "User can interrupt processing via ComfyUI's cancel/interrupt"
    - "Batch complete signal is True only when processing last image"
  artifacts:
    - path: "nodes/batch_loader.py"
      provides: "BatchImageLoader with iteration support"
      exports: ["BatchImageLoader"]
    - path: "tests/test_batch_loader.py"
      provides: "Updated tests for iteration behavior"
      min_lines: 100
  key_links:
    - from: "nodes/batch_loader.py"
      to: "utils/iteration_state.py"
      via: "IterationState import"
      pattern: "from.*iteration_state import IterationState"
    - from: "nodes/batch_loader.py"
      to: "utils/queue_control.py"
      via: "queue control import"
      pattern: "from.*queue_control import"
---

<objective>
Extend BatchImageLoader with full iteration support for queue-per-image batch processing.

Purpose: Users can now process an entire directory by clicking Queue once, with each image flowing through separately and triggering the next queue item automatically.

Output: Updated BatchImageLoader node with new inputs (iteration_mode, error_handling, start_index), new outputs (INDEX, STATUS, BATCH_COMPLETE), and automatic queue triggering.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-batch-iteration/03-CONTEXT.md
@.planning/phases/03-batch-iteration/03-RESEARCH.md
@.planning/phases/03-batch-iteration/03-01-SUMMARY.md
@nodes/batch_loader.py
@tests/test_batch_loader.py
@utils/iteration_state.py
@utils/queue_control.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update BatchImageLoader inputs and outputs</name>
  <files>nodes/batch_loader.py</files>
  <action>
Update the BatchImageLoader class with new inputs and outputs per CONTEXT.md decisions.

**New inputs in INPUT_TYPES:**
- `iteration_mode`: Combo dropdown `["Continue", "Reset"]` with default "Continue"
  - "Continue" = persist position, resume from current index on next run
  - "Reset" = start fresh from index 0
- `error_handling`: Combo dropdown `["Stop on error", "Skip on error"]` with default "Stop on error"
- `start_index` (optional): INT with default 0, min 0, max 99999 - for resuming from specific position

**Updated RETURN_TYPES and RETURN_NAMES:**
Current: `("IMAGE", "INT", "INT", "STRING", "STRING")`
Current names: `("IMAGE", "TOTAL_COUNT", "CURRENT_INDEX", "FILENAME", "BASENAME")`

New: `("IMAGE", "INT", "INT", "STRING", "STRING", "STRING", "BOOLEAN")`
New names: `("IMAGE", "TOTAL_COUNT", "INDEX", "FILENAME", "BASENAME", "STATUS", "BATCH_COMPLETE")`

Note: CURRENT_INDEX is renamed to INDEX and is now 0-based (first image = 0), not 1-based.

**Import the utilities:**
```python
from ..utils.iteration_state import IterationState
from ..utils.queue_control import trigger_next_queue, should_continue
```

**Update load_image method signature** to accept new parameters:
- `iteration_mode: str = "Continue"`
- `error_handling: str = "Stop on error"`
- `start_index: int = 0`

Remove the hidden `current_index` input - we now use internal state management via IterationState.
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.nodes.batch_loader import BatchImageLoader; print(BatchImageLoader.INPUT_TYPES())"` - shows new inputs</verify>
  <done>BatchImageLoader has new inputs (iteration_mode, error_handling, start_index) and new outputs (INDEX as 0-based, STATUS, BATCH_COMPLETE)</done>
</task>

<task type="auto">
  <name>Task 2: Implement iteration logic in load_image</name>
  <files>nodes/batch_loader.py</files>
  <action>
Implement the full iteration logic in the load_image method.

**State management flow:**
1. Normalize directory path with `os.path.normpath`
2. Get state: `state = IterationState.get_state(directory)`
3. Check for directory change: If directory differs from state's last_directory, reset state
4. Handle iteration_mode:
   - If "Reset": call `IterationState.reset(directory)`
   - If "Continue": use existing state
5. Handle start_index: If start_index > 0 and state.index == 0, set state.index = start_index
6. Set total count: `IterationState.set_total_count(directory, len(files))`

**Processing flow:**
1. Get current index from state (0-based)
2. Load image at that index (with error handling based on error_handling mode)
3. Determine batch_complete: `current_index >= total_count - 1`
4. If not batch_complete: call `trigger_next_queue()` to queue next execution
5. Advance index: `IterationState.advance(directory)`
6. If batch complete: call `IterationState.wrap_index(directory)` to reset for re-run

**Status values:**
- 'processing' - currently processing (not last image)
- 'completed' - finished last image (batch_complete = True)
- Set status in state before returning

**Error handling modes:**
- "Stop on error": Raise exception if image fails to load (current behavior)
- "Skip on error": Log error, advance to next, return a placeholder or skip

For "Skip on error", implement retry loop similar to current code but track skipped count.

**Update IS_CHANGED:**
Include the current index in the return value to force re-execution each iteration:
```python
@classmethod
def IS_CHANGED(cls, directory, filter_preset, iteration_mode, **kwargs):
    if not directory:
        return ""
    state = IterationState.get_state(directory)
    return f"{directory}|{state.get('index', 0)}|{iteration_mode}"
```

**Update VALIDATE_INPUTS:**
Add new parameters to signature and validation if needed.

**Return tuple:**
```python
return (image_tensor, total_count, current_index, filename, basename, status, batch_complete)
```
Where:
- current_index is 0-based (first image = 0)
- status is 'processing' or 'completed'
- batch_complete is True only on last image
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.nodes.batch_loader import BatchImageLoader; b = BatchImageLoader(); print('load_image' in dir(b))"` - imports without error</verify>
  <done>load_image processes current index, triggers next queue, advances state, outputs correct status and batch_complete</done>
</task>

<task type="auto">
  <name>Task 3: Update tests for iteration behavior</name>
  <files>tests/test_batch_loader.py</files>
  <action>
Update `tests/test_batch_loader.py` with new tests for iteration behavior.

**New tests to add:**

1. `test_load_image_returns_0_based_index`:
   - Load first image, verify INDEX output is 0 (not 1)

2. `test_iteration_mode_reset_starts_from_zero`:
   - Load with Continue, verify index advances
   - Load with Reset, verify index back to 0

3. `test_iteration_mode_continue_preserves_position`:
   - Simulate multiple executions with Continue mode
   - Verify each execution advances the index

4. `test_batch_complete_true_on_last_image`:
   - Create directory with 2 images
   - First load: batch_complete should be False
   - Advance state, second load: batch_complete should be True

5. `test_status_output_processing_vs_completed`:
   - Not last image: status = 'processing'
   - Last image: status = 'completed'

6. `test_start_index_input`:
   - Set start_index = 1
   - First load should return image at index 1 (second image)

7. `test_directory_change_resets_state`:
   - Load from directory A, advance index
   - Load from directory B
   - Load from directory A again - should be reset to 0 (due to B in between)

   Actually per CONTEXT.md: auto-reset on directory change means if the directory changes FROM the stored last_directory, reset. So:
   - Load dir A at index 0, advance to 1
   - Load dir A again - should continue at 1
   - Load dir B - resets because different from last (A)
   - Load dir A again - resets because different from last (B)

8. `test_error_handling_stop_on_error`:
   - Mock image load to fail
   - Verify exception raised with "Stop on error"

9. `test_error_handling_skip_on_error`:
   - Create dir with 3 images, middle one fails
   - With "Skip on error", should load first, skip second, load third

**Update existing tests:**
- Update return value unpacking to handle new 7-tuple output
- Rename any CURRENT_INDEX references to INDEX
- Adjust for 0-based indexing

**Mocking pattern:**
Mock `IterationState` methods to test iteration logic without file system dependencies.
Mock `trigger_next_queue` to verify it's called at the right time.
  </action>
  <verify>Run `python -m pytest tests/test_batch_loader.py -v` - all tests pass including new iteration tests</verify>
  <done>Comprehensive tests verify iteration state management, mode switching, status output, and batch completion detection</done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` - all tests pass
2. Verify node structure: `python -c "from comfyui_batch_image_processing import NODE_CLASS_MAPPINGS; print(NODE_CLASS_MAPPINGS['BatchImageLoader'].RETURN_NAMES)"` shows all 7 outputs
</verification>

<success_criteria>
- BatchImageLoader accepts iteration_mode, error_handling, start_index inputs
- Node outputs 0-based INDEX, STATUS, and BATCH_COMPLETE
- State persists across executions in Continue mode
- State resets in Reset mode or on directory change
- Queue triggering occurs for all but last image
- batch_complete is True only on last image
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-iteration/03-02-SUMMARY.md`
</output>
