---
phase: 03-batch-iteration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - nodes/batch_loader.py
  - tests/test_batch_loader.py
autonomous: true

must_haves:
  truths:
    - "Each image triggers a separate workflow execution via queue-per-image pattern"
    - "Node outputs current image index (0-based)"
    - "Node outputs total image count"
    - "Processing proceeds through all images in order"
    - "User can interrupt processing via ComfyUI's cancel/interrupt"
    - "Batch complete signal is True only when processing last image"
    - "Continue mode preserves index on interrupt, Reset mode clears index on interrupt"
    - "Auto Queue stops when batch completes"
  artifacts:
    - path: "nodes/batch_loader.py"
      provides: "BatchImageLoader with iteration support"
      exports: ["BatchImageLoader"]
    - path: "tests/test_batch_loader.py"
      provides: "Updated tests for iteration behavior including interruption"
      min_lines: 120
  key_links:
    - from: "nodes/batch_loader.py"
      to: "utils/iteration_state.py"
      via: "IterationState import"
      pattern: "from.*iteration_state import IterationState"
    - from: "nodes/batch_loader.py"
      to: "utils/queue_control.py"
      via: "queue control import"
      pattern: "from.*queue_control import"
    - from: "nodes/batch_loader.py"
      to: "trigger_next_queue"
      via: "conditional call when not batch_complete"
      pattern: "if not batch_complete.*trigger_next_queue|trigger_next_queue.*if.*should_continue"
    - from: "nodes/batch_loader.py"
      to: "stop_auto_queue"
      via: "call when batch_complete is True"
      pattern: "if batch_complete.*stop_auto_queue|stop_auto_queue.*if.*is_complete"
---

<objective>
Extend BatchImageLoader with full iteration support for queue-per-image batch processing.

Purpose: Users can now process an entire directory by clicking Queue once, with each image flowing through separately and triggering the next queue item automatically.

Output: Updated BatchImageLoader node with new inputs (iteration_mode, error_handling, start_index), new outputs (INDEX, STATUS, BATCH_COMPLETE), and automatic queue triggering with stop signal on completion.
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-batch-iteration/03-CONTEXT.md
@.planning/phases/03-batch-iteration/03-RESEARCH.md
@.planning/phases/03-batch-iteration/03-01-SUMMARY.md
@nodes/batch_loader.py
@tests/test_batch_loader.py
@utils/iteration_state.py
@utils/queue_control.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update BatchImageLoader inputs and outputs</name>
  <files>nodes/batch_loader.py</files>
  <action>
Update the BatchImageLoader class with new inputs and outputs per CONTEXT.md decisions.

**New inputs in INPUT_TYPES:**
- `iteration_mode`: Combo dropdown `["Continue", "Reset"]` with default "Continue"
  - "Continue" = persist position, resume from current index on next run
  - "Reset" = start fresh from index 0
- `error_handling`: Combo dropdown `["Stop on error", "Skip on error"]` with default "Stop on error"
- `start_index` (optional): INT with default 0, min 0, max 99999 - for resuming from specific position

**Updated RETURN_TYPES and RETURN_NAMES:**
Current: `("IMAGE", "INT", "INT", "STRING", "STRING")`
Current names: `("IMAGE", "TOTAL_COUNT", "CURRENT_INDEX", "FILENAME", "BASENAME")`

New: `("IMAGE", "INT", "INT", "STRING", "STRING", "STRING", "BOOLEAN")`
New names: `("IMAGE", "TOTAL_COUNT", "INDEX", "FILENAME", "BASENAME", "STATUS", "BATCH_COMPLETE")`

Note: CURRENT_INDEX is renamed to INDEX and is now 0-based (first image = 0), not 1-based.

**Import the utilities:**
```python
from ..utils.iteration_state import IterationState
from ..utils.queue_control import trigger_next_queue, stop_auto_queue, should_continue
```

**Update load_image method signature** to accept new parameters:
- `iteration_mode: str = "Continue"`
- `error_handling: str = "Stop on error"`
- `start_index: int = 0`

Remove the hidden `current_index` input - we now use internal state management via IterationState.
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.nodes.batch_loader import BatchImageLoader; print(BatchImageLoader.INPUT_TYPES())"` - shows new inputs</verify>
  <done>BatchImageLoader has new inputs (iteration_mode, error_handling, start_index) and new outputs (INDEX as 0-based, STATUS, BATCH_COMPLETE)</done>
</task>

<task type="auto">
  <name>Task 2: Implement state management in load_image</name>
  <files>nodes/batch_loader.py</files>
  <action>
Implement state management logic at the start of load_image method.

**State management flow (first half of load_image):**

1. Normalize directory path with `os.path.normpath`

2. Get state: `state = IterationState.get_state(directory)`

3. Check for directory change: If directory differs from state's last_directory, reset state
   - This auto-resets when user switches directories

4. Handle iteration_mode:
   - If "Reset": call `IterationState.reset(directory)` - clears index to 0
   - If "Continue": use existing state (preserves position including after interrupt)

5. Handle start_index: If start_index > 0 and state.index == 0, set state.index = start_index
   - Allows user to manually resume from specific position

6. Set total count: `IterationState.set_total_count(directory, len(files))`

**Status state machine (explicit):**
- Set status to 'processing' at start of load_image, before any image loading
- Status stays 'processing' throughout normal execution
- Status only becomes 'completed' when batch_complete=True (last image successfully loaded)
- On error with "Stop on error": exception raised, status remains 'processing' (will be 'processing' on next run)
- On error with "Skip on error": stays 'processing', advances to next image

**Interruption behavior (per iteration_mode):**
- "Continue" mode: Index is NOT reset on interrupt. Next run resumes from current position.
- "Reset" mode: User explicitly chose Reset, so index resets on each run anyway.
- Note: ComfyUI interrupt doesn't call our code - we just don't advance. Next run picks up where we left off.

**Update IS_CHANGED:**
Include the current index in the return value to force re-execution each iteration:
```python
@classmethod
def IS_CHANGED(cls, directory, filter_preset, iteration_mode, **kwargs):
    if not directory:
        return ""
    state = IterationState.get_state(directory)
    return f"{directory}|{state.get('index', 0)}|{iteration_mode}"
```

**Update VALIDATE_INPUTS:**
Add new parameters to signature and validation if needed.
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.nodes.batch_loader import BatchImageLoader; b = BatchImageLoader(); print('load_image' in dir(b))"` - imports without error</verify>
  <done>State management handles directory changes, iteration modes, start_index, and tracks status correctly per state machine</done>
</task>

<task type="auto">
  <name>Task 3: Implement processing flow and queue control in load_image</name>
  <files>nodes/batch_loader.py</files>
  <action>
Implement the processing flow and queue control in load_image method.

**Processing flow (second half of load_image):**

1. Get current index from state (0-based)

2. Load image at that index:
   - "Stop on error": Raise exception if image fails to load (current behavior)
   - "Skip on error": Log error, advance index, recursively call load_image for next
     - Track skip count to avoid infinite loop (max = total_count)
     - If all images skipped, raise exception

3. Determine batch_complete: `current_index >= total_count - 1`

4. Queue control based on batch_complete:
   - If NOT batch_complete: call `trigger_next_queue()` to queue next execution
   - If batch_complete:
     - Call `stop_auto_queue()` to signal ComfyUI to stop Auto Queue
     - Call `IterationState.wrap_index(directory)` to reset for re-run

5. Advance index AFTER successful load: `IterationState.advance(directory)`
   - This means interrupt during load leaves index unchanged (Continue mode resumes here)

6. Set final status:
   - If batch_complete: status = 'completed'
   - Else: status = 'processing'

**Return tuple:**
```python
return (image_tensor, total_count, current_index, filename, basename, status, batch_complete)
```
Where:
- current_index is 0-based (first image = 0)
- status is 'processing' or 'completed'
- batch_complete is True only on last image
  </action>
  <verify>Run `python -c "from comfyui_batch_image_processing.nodes.batch_loader import BatchImageLoader; b = BatchImageLoader(); print('load_image' in dir(b))"` - imports without error</verify>
  <done>load_image processes current index, triggers next queue when continuing, stops Auto Queue on completion, advances state correctly</done>
</task>

<task type="auto">
  <name>Task 4: Update tests for iteration behavior</name>
  <files>tests/test_batch_loader.py</files>
  <action>
Update `tests/test_batch_loader.py` with new tests for iteration behavior.

**New tests to add:**

1. `test_load_image_returns_0_based_index`:
   - Load first image, verify INDEX output is 0 (not 1)

2. `test_iteration_mode_reset_starts_from_zero`:
   - Load with Continue, verify index advances
   - Load with Reset, verify index back to 0

3. `test_iteration_mode_continue_preserves_position`:
   - Simulate multiple executions with Continue mode
   - Verify each execution advances the index

4. `test_batch_complete_true_on_last_image`:
   - Create directory with 2 images
   - First load: batch_complete should be False
   - Advance state, second load: batch_complete should be True

5. `test_status_output_processing_vs_completed`:
   - Not last image: status = 'processing'
   - Last image: status = 'completed'

6. `test_start_index_input`:
   - Set start_index = 1
   - First load should return image at index 1 (second image)

7. `test_directory_change_resets_state`:
   - Load from directory A, advance index
   - Load from directory B
   - Load from directory A again - should be reset to 0 (due to B in between)

   Per CONTEXT.md: auto-reset on directory change means if the directory changes FROM the stored last_directory, reset. So:
   - Load dir A at index 0, advance to 1
   - Load dir A again - should continue at 1
   - Load dir B - resets because different from last (A)
   - Load dir A again - resets because different from last (B)

8. `test_error_handling_stop_on_error`:
   - Mock image load to fail
   - Verify exception raised with "Stop on error"

9. `test_error_handling_skip_on_error`:
   - Create dir with 3 images, middle one fails
   - With "Skip on error", should load first, skip second, load third

10. `test_interruption_continue_mode_preserves_index`:
    - Mock an interruption scenario (simulate by not completing execution)
    - With "Continue" mode, next execution should resume at same index
    - Verify state.index unchanged after simulated interrupt

11. `test_interruption_reset_mode_clears_index`:
    - Advance index to 2
    - With "Reset" mode, next execution starts at 0 regardless of prior state
    - Verify this is just testing the Reset mode behavior (Reset always starts at 0)

12. `test_trigger_next_queue_called_when_not_complete`:
    - Mock trigger_next_queue
    - Load non-last image
    - Verify trigger_next_queue was called exactly once

13. `test_trigger_next_queue_not_called_on_last_image`:
    - Mock trigger_next_queue
    - Load last image
    - Verify trigger_next_queue was NOT called

14. `test_stop_auto_queue_called_on_batch_complete`:
    - Mock stop_auto_queue
    - Load last image (batch_complete=True)
    - Verify stop_auto_queue was called exactly once

**Update existing tests:**
- Update return value unpacking to handle new 7-tuple output
- Rename any CURRENT_INDEX references to INDEX
- Adjust for 0-based indexing

**Mocking pattern:**
Mock `IterationState` methods to test iteration logic without file system dependencies.
Mock `trigger_next_queue` and `stop_auto_queue` to verify they're called at the right time.
  </action>
  <verify>Run `python -m pytest tests/test_batch_loader.py -v` - all tests pass including new iteration tests</verify>
  <done>Comprehensive tests verify iteration state management, mode switching, status output, batch completion detection, interruption behavior, and queue control calls</done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` - all tests pass
2. Verify node structure: `python -c "from comfyui_batch_image_processing import NODE_CLASS_MAPPINGS; print(NODE_CLASS_MAPPINGS['BatchImageLoader'].RETURN_NAMES)"` shows all 7 outputs
</verification>

<success_criteria>
- BatchImageLoader accepts iteration_mode, error_handling, start_index inputs
- Node outputs 0-based INDEX, STATUS, and BATCH_COMPLETE
- State persists across executions in Continue mode (including after interrupt)
- State resets in Reset mode or on directory change
- Queue triggering occurs for all but last image
- stop_auto_queue called when batch completes
- batch_complete is True only on last image
- Interruption tests verify Continue mode preserves index
- All tests pass including queue control mocking tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-iteration/03-02-SUMMARY.md`
</output>
