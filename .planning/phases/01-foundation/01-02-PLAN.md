---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - nodes/batch_loader.py
  - utils/file_utils.py
  - utils/__init__.py
  - tests/test_batch_loader.py
  - tests/test_file_utils.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "User can specify a directory path and node loads images from it"
    - "User can filter images using preset dropdown or custom glob pattern"
    - "Images are loaded in natural sort order (img2 before img10)"
    - "Node outputs IMAGE tensor, TOTAL_COUNT, CURRENT_INDEX (1-based), FILENAME, and BASENAME"
    - "Invalid directory path shows clear error at queue time"
    - "Zero matching files shows clear error message"
  artifacts:
    - path: "nodes/batch_loader.py"
      provides: "Complete BatchImageLoader implementation"
      contains: "def load_image"
      min_lines: 80
    - path: "utils/file_utils.py"
      provides: "File filtering and pattern matching"
      exports: ["filter_files_by_patterns", "get_pattern_for_preset"]
    - path: "tests/test_batch_loader.py"
      provides: "Integration tests for BatchImageLoader"
      min_lines: 50
  key_links:
    - from: "nodes/batch_loader.py"
      to: "utils/file_utils.py"
      via: "import filter_files_by_patterns"
      pattern: "from ..utils.file_utils import"
    - from: "nodes/batch_loader.py"
      to: "utils/image_utils.py"
      via: "import load_image_as_tensor"
      pattern: "from ..utils.image_utils import"
    - from: "nodes/batch_loader.py"
      to: "utils/sorting.py"
      via: "import natural_sort_key"
      pattern: "from ..utils.sorting import"
---

<objective>
Implement the complete BatchImageLoader functionality including file filtering, validation, and image loading.

Purpose: Complete the Phase 1 requirements so users can load images from a directory with glob filtering and natural sort order. This makes the BatchImageLoader node fully functional for Phase 2 (saving) and Phase 3 (iteration).

Output: Fully functional BatchImageLoader node that loads images from directories, filters by pattern, sorts naturally, and outputs all required data.
</objective>

<execution_context>
@./.claude/agents/gsd-planner.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement file filtering utilities</name>
  <files>
    utils/file_utils.py
    utils/__init__.py
    tests/test_file_utils.py
  </files>
  <action>
Create file filtering utilities:

1. Create `utils/file_utils.py`:

   Implement `get_pattern_for_preset(preset: str, custom_pattern: str = "") -> str`:
   - "All Images" -> "*.png,*.jpg,*.jpeg,*.webp"
   - "PNG Only" -> "*.png"
   - "JPG Only" -> "*.jpg,*.jpeg"
   - "Custom" -> return custom_pattern (or default if empty)
   - Default pattern: "*.png,*.jpg,*.jpeg,*.webp"

   Implement `filter_files_by_patterns(directory: str, pattern_string: str) -> list[str]`:
   - Parse comma-separated patterns (strip whitespace)
   - List files in directory (top-level only, no recursion)
   - Filter using fnmatch with case-insensitive matching (lowercase both)
   - Only include regular files (not directories)
   - Return list of filenames (not full paths)

2. Update `utils/__init__.py`:
   - Add exports for `filter_files_by_patterns` and `get_pattern_for_preset`

3. Create `tests/test_file_utils.py`:
   - Test `get_pattern_for_preset`:
     - All preset values return correct patterns
     - Custom with empty string returns default
     - Custom with pattern returns that pattern
   - Test `filter_files_by_patterns`:
     - Matches *.png files (case-insensitive: .PNG, .Png)
     - Matches multiple patterns (*.png,*.jpg)
     - Excludes non-matching files
     - Excludes subdirectories
     - Returns filenames only (not full paths)
  </action>
  <verify>
    - Run tests: `python -m pytest tests/test_file_utils.py -v`
    - All tests pass
  </verify>
  <done>
    - filter_files_by_patterns correctly filters files with case-insensitive matching
    - get_pattern_for_preset returns correct pattern for each preset
    - At least 8 test cases pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete BatchImageLoader implementation</name>
  <files>
    nodes/batch_loader.py
    tests/test_batch_loader.py
    tests/conftest.py
  </files>
  <action>
Complete the BatchImageLoader node:

1. Update `nodes/batch_loader.py`:

   Add imports:
   - os, pathlib for path handling
   - from ..utils.sorting import natural_sort_key
   - from ..utils.file_utils import filter_files_by_patterns, get_pattern_for_preset
   - from ..utils.image_utils import load_image_as_tensor

   Update INPUT_TYPES:
   - "directory": STRING with default="" and tooltip "Path to image directory"
   - "filter_preset": COMBO ["All Images", "PNG Only", "JPG Only", "Custom"], default "All Images"
   - Optional "custom_pattern": STRING with default "*.png,*.jpg,*.jpeg,*.webp"
   - Hidden "current_index": INT with default 0 (for iteration control in Phase 3)

   Add VALIDATE_INPUTS classmethod:
   - Check directory is not empty -> "Directory path is required"
   - Check directory exists (os.path.isdir) -> "Directory does not exist: {path}"
   - Get pattern using get_pattern_for_preset
   - Get matching files using filter_files_by_patterns
   - Check files not empty -> "No images found matching pattern: {pattern}"
   - Return True if all pass

   Add IS_CHANGED classmethod:
   - Return string combining directory, filter_preset, custom_pattern, current_index
   - This ensures re-execution when inputs change

   Implement load_image method:
   - Get pattern from preset/custom
   - Get matching files and sort with natural_sort_key
   - Calculate total_count = len(files)
   - Get current file (current_index mod total_count to handle wraparound)
   - Build full path, load image using load_image_as_tensor
   - Extract filename and basename (filename without extension)
   - Return tuple: (image_tensor, total_count, current_index + 1, filename, basename)
   - Note: CURRENT_INDEX output is 1-based (add 1 to 0-based internal index)

   Handle corrupted files:
   - Wrap load_image_as_tensor in try/except
   - On error, skip to next file (increment index, retry)
   - If all files fail, raise clear error

2. Update `tests/conftest.py`:
   - Add fixture `temp_image_dir` that creates temp directory with test images
   - Create at least 3 PNG images named img1.png, img2.png, img10.png
   - Use PIL to create simple solid-color images (100x100)

3. Create `tests/test_batch_loader.py`:
   - Test INPUT_TYPES returns correct structure
   - Test VALIDATE_INPUTS:
     - Returns error string for empty directory
     - Returns error string for nonexistent directory
     - Returns error string for zero matching files
     - Returns True for valid directory with images
   - Test load_image:
     - Returns correct tuple length (5 elements)
     - IMAGE is torch.Tensor with shape [1, H, W, 3]
     - TOTAL_COUNT matches number of files
     - CURRENT_INDEX is 1-based (first image returns 1)
     - FILENAME includes extension
     - BASENAME excludes extension
   - Test natural sort ordering:
     - With files img1.png, img2.png, img10.png, order should be 1, 2, 10
  </action>
  <verify>
    - Run all tests: `python -m pytest tests/ -v`
    - All tests pass
    - Manual check: `python -c "from nodes.batch_loader import BatchImageLoader; print(BatchImageLoader.INPUT_TYPES())"`
  </verify>
  <done>
    - BatchImageLoader.load_image returns all 5 outputs correctly
    - VALIDATE_INPUTS catches invalid paths and empty results
    - Images load in natural sort order
    - All tests pass (at least 10 test cases)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Full test suite:
   ```bash
   python -m pytest tests/ -v --tb=short
   ```
   Expected: All tests pass

2. Manual load_image test (requires temp directory):
   ```python
   import tempfile, os
   from PIL import Image
   from nodes.batch_loader import BatchImageLoader

   # Create temp dir with test images
   with tempfile.TemporaryDirectory() as tmpdir:
       for name in ['img1.png', 'img2.png', 'img10.png']:
           img = Image.new('RGB', (100, 100), color='red')
           img.save(os.path.join(tmpdir, name))

       loader = BatchImageLoader()
       result = loader.load_image(tmpdir, "All Images", "", 0)
       print(f"Total: {result[1]}, Index: {result[2]}, File: {result[3]}, Base: {result[4]}")
       print(f"Image shape: {result[0].shape}")
   ```
   Expected output:
   - Total: 3
   - Index: 1 (1-based)
   - File: img1.png (natural sort puts img1 first)
   - Base: img1
   - Image shape: torch.Size([1, 100, 100, 3])

3. Validate inputs check:
   ```python
   from nodes.batch_loader import BatchImageLoader
   print(BatchImageLoader.VALIDATE_INPUTS("/nonexistent/path", "All Images"))
   ```
   Expected: Error string about directory not existing
</verification>

<success_criteria>
Phase 1 requirements complete:
- [LOAD-01] Node accepts directory path input - INPUT_TYPES has directory STRING
- [LOAD-02] Node loads images from directory - load_image reads files from directory
- [LOAD-03] Node supports glob pattern filtering - filter_preset + custom_pattern
- [LOAD-04] Images sorted in natural order - natural_sort_key applied to file list
- [LOAD-05] Node outputs total image count - TOTAL_COUNT output
- [LOAD-06] Node outputs current image filename - FILENAME and BASENAME outputs

Additional criteria:
- CURRENT_INDEX is 1-based (first image = 1)
- Invalid paths caught by VALIDATE_INPUTS at queue time
- Zero matching files gives clear error message
- Corrupted files are skipped, not fatal errors
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
